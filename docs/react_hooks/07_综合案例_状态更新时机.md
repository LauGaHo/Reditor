# 综合案例：状态更新时机与 Hook 协同

## 案例背景

在实现 Reditor 编辑器的"按回车创建新块并自动聚焦"功能时，我们遇到了一个典型的 React 状态更新时机问题。这个案例完美展示了多个 Hook 的协同工作和常见的陷阱。

## 问题场景

### 功能需求
1. 用户在块中按回车键
2. 在当前块后面创建新块
3. 自动将焦点设置到新块

### 技术实现思路
1. 使用 `useState` 管理块列表和新块 ID
2. 使用 `useImperativeHandle` 暴露 Block 组件的 focus 方法
3. 使用 `useEffect` 监听新块创建，设置焦点

## 第一次实现：遇到的问题

### 错误的代码

```tsx
const handleEnterPress = useCallback((blockId: string) => {
  setBlocks((prevBlocks) => {
    const blockIndex = prevBlocks.findIndex(block => block.id === blockId);
    const newBlock = createBlock();

    const newBlocks = [
      ...prevBlocks.slice(0, blockIndex + 1),
      newBlock,
      ...prevBlocks.slice(blockIndex + 1),
    ];

    // ❌ 问题：在 setBlocks 回调内部调用 setNewBlockId
    setNewBlockId(newBlock.id);

    return newBlocks;
  });
}, []);

// 尝试设置焦点
useEffect(() => {
  if (newBlockId) {
    const newBlockElement = blockRefs.current.get(newBlockId);
    console.log("新块元素：", newBlockElement); // ❌ undefined!
    if (newBlockElement) {
      newBlockElement.focus();
    }
  }
}, [newBlockId]);
```

### 问题现象
- `console.log` 输出 `undefined`
- 新创建的块无法获得焦点
- 用户体验不佳

## 问题分析：执行时序解析

### 错误实现的执行时序

```
1. 用户按回车 → handleEnterPress 执行
2. setBlocks 开始执行，进入回调函数
   |
   ├─ 创建 newBlocks 数组
   ├─ setNewBlockId(newBlock.id) 立即执行 ⚠️
   └─ return newBlocks
3. React 检测到两个状态更新：
   ├─ blocks 需要重新渲染
   └─ newBlockId 变化 → 调度 useEffect
4. React 开始批量处理更新
5. ❌ useEffect 立即执行（因为 newBlockId 已变）
6. 此时新的 Block 组件还在渲染中
7. blockRefs.current.get(newBlockId) → undefined
8. Block 组件完成挂载，ref 才被设置
```

### 关键问题：useState 回调内的 setState

当在 `setState` 的回调函数内部调用另一个 `setState` 时，React 会认为这是"渲染期间的状态更新"，导致相关的 effects 过早执行。

## 解决方案演进

### 方案1：使用 useLayoutEffect

```tsx
// 第一种解决思路：改变 effect 的执行时机
useLayoutEffect(() => {
  if (newBlockId) {
    const newBlockElement = blockRefs.current.get(newBlockId);
    console.log("新块元素：", newBlockElement); // ✅ 有值了
    if (newBlockElement) {
      newBlockElement.focus();
    }
  }
}, [newBlockId]);
```

**原理：** `useLayoutEffect` 在 DOM 更新完成后、浏览器绘制前同步执行，此时所有组件都已挂载完成。

### 方案2：调整状态更新时机（最终方案）

```tsx
const handleEnterPress = useCallback((blockId: string) => {
  const newBlock = createBlock(); // ✅ 移到外面

  setBlocks((prevBlocks) => {
    const blockIndex = prevBlocks.findIndex(block => block.id === blockId);

    const newBlocks = [
      ...prevBlocks.slice(0, blockIndex + 1),
      newBlock,
      ...prevBlocks.slice(blockIndex + 1),
    ];

    return newBlocks; // ✅ 回调只处理 blocks 更新
  });

  // ✅ 关键：将 setNewBlockId 移到外部
  setNewBlockId(newBlock.id);
}, []);

// 现在 useEffect 也能正常工作
useEffect(() => {
  if (newBlockId) {
    const newBlockElement = blockRefs.current.get(newBlockId);
    console.log("新块元素：", newBlockElement); // ✅ 正常获取
    if (newBlockElement) {
      newBlockElement.focus();
    }
  }
}, [newBlockId]);
```

### 正确实现的执行时序

```
1. 用户按回车 → handleEnterPress 执行
2. setBlocks 执行，只处理 blocks 数组更新
3. setNewBlockId 执行
4. React 批量处理两个状态更新：
   ├─ 开始重新渲染
   ├─ 新的 Block 组件挂载
   ├─ useImperativeHandle 创建 handle
   ├─ getRefCallback 设置 ref
   └─ DOM 更新完成
5. ✅ useEffect 执行，此时 ref 已存在
6. 成功设置焦点
```

## 技术要点深入分析

### 1. useState 状态更新的批量处理

React 18 中的自动批处理机制：

```tsx
// ✅ 正确：React 会批量处理
function handleClick() {
  setCount(count + 1);
  setName('John');
  setAge(30);
  // React 只会重新渲染一次
}

// ⚠️ 容易出问题：在回调中调用 setState
function handleClick() {
  setCount(prevCount => {
    setName('John'); // 可能导致时序问题
    return prevCount + 1;
  });
}
```

### 2. useImperativeHandle 最佳实践

```tsx
// Block.tsx - 标准的 useImperativeHandle 用法
export interface BlockHandle {
  focus: () => void;
}

const BlockComponent = forwardRef<BlockHandle, BlockProps>((props, ref) => {
  const divRef = useRef<HTMLDivElement>(null);

  // 暴露给父组件的方法
  useImperativeHandle(
    ref,
    () => ({
      focus: () => {
        divRef.current?.focus();
      },
    }),
    [], // 空依赖数组，保证引用稳定
  );

  return <div ref={divRef} contentEditable />;
});
```

**设计优势：**
- 封装内部实现细节
- 提供类型安全的接口
- 便于测试和维护

### 3. useEffect vs useLayoutEffect 选择

| Hook | 执行时机 | 适用场景 | 是否阻塞绘制 |
|------|---------|----------|-------------|
| `useEffect` | DOM 更新后，绘制完成后 | 副作用、异步操作 | ❌ 否 |
| `useLayoutEffect` | DOM 更新后，绘制前 | DOM 测量、同步更新 | ✅ 是 |

**在我们的场景中：**
- ✅ `useEffect` 足够（修复状态更新时机后）
- ✅ `useLayoutEffect` 更安全（但会阻塞绘制）

## 延伸学习：React 状态更新机制

### 批量更新的边界

```tsx
// 同步函数中：会批量更新
function handleClick() {
  setStateA(valueA);
  setStateB(valueB); // 批量处理
}

// 异步操作中：React 18 也会批量更新
async function handleAsync() {
  await fetchData();
  setStateA(valueA);
  setStateB(valueB); // React 18: 也会批量处理
}

// 在 useState 回调中：需要小心
function problematicUpdate() {
  setStateA(prevA => {
    setStateB(valueB); // ⚠️ 可能破坏批量更新
    return newA;
  });
}
```

### 调试状态更新时序

```tsx
useEffect(() => {
  console.log('Effect 执行时机');
  console.log('DOM 是否更新完成？', document.getElementById('new-block'));
}, [dependency]);

useLayoutEffect(() => {
  console.log('LayoutEffect 执行时机');
  console.log('DOM 是否更新完成？', document.getElementById('new-block'));
}, [dependency]);
```

## 最佳实践总结

### ✅ 推荐做法

1. **状态更新分离**
   ```tsx
   // 将不同的状态更新分开调用
   setState1(value1);
   setState2(value2);
   ```

2. **避免在回调中调用 setState**
   ```tsx
   // ❌ 避免
   setState1(prev => {
     setState2(value); // 容易出问题
     return newValue;
   });

   // ✅ 推荐
   setState1(newValue);
   setState2(value);
   ```

3. **选择合适的 Effect Hook**
   ```tsx
   // DOM 操作和测量用 useLayoutEffect
   useLayoutEffect(() => {
     element.focus();
   }, []);

   // 其他副作用用 useEffect
   useEffect(() => {
     fetchData();
   }, []);
   ```

4. **使用 useImperativeHandle 封装组件方法**
   ```tsx
   const Component = forwardRef((props, ref) => {
     useImperativeHandle(ref, () => ({
       publicMethod: () => { /* 实现 */ },
     }), []);
   });
   ```

### ❌ 需要避免的陷阱

1. **在 setState 回调中调用其他 setState**
2. **过早执行依赖新 DOM 的操作**
3. **混淆 useEffect 和 useLayoutEffect 的使用场景**
4. **直接暴露 DOM 元素而不是方法接口**

## 总结

这个案例展示了 React Hooks 协同工作时需要注意的细节：

1. **状态更新时机** - 影响整个应用的执行流程
2. **Hook 执行顺序** - 理解 React 的渲染生命周期
3. **组件间通信** - 使用 ref 和 useImperativeHandle 的最佳实践
4. **调试技巧** - 通过 console.log 和理解执行时序来定位问题

掌握这些概念对于构建复杂的 React 应用非常重要，它们是性能优化和用户体验提升的基础。