# 动态组件渲染与工厂模式 - 阶段3实践总结

## 概述

在阶段3的块类型系统实现中，我们接触了多个之前未使用的 React 特性和设计模式。这些特性让我们能够创建一个可扩展、符合开闭原则的组件架构。

## 🆕 新接触的 React 特性

### 1. 动态组件渲染

**概念：** 将组件存储在变量中，并根据运行时条件动态选择和渲染组件

```typescript
// ✅ 动态组件渲染的实现
const BlockFactoryComponent = ({ blockType, ...props }, ref) => {
  const registryItem = blockRegistry[blockType];
  const Component = registryItem.component; // 动态获取组件

  return <Component ref={ref} {...props} />; // 动态渲染组件
};

// 使用时
<BlockFactory blockType="h1" /> // 渲染 H1Block
<BlockFactory blockType="h2" /> // 渲染 H2Block
```

**核心原理：**
- React 识别首字母大写的变量作为组件
- 组件本质上是函数，可以像其他值一样存储和传递
- JSX 中的 `<Component />` 等价于 `React.createElement(Component)`

**应用场景：**
```typescript
// 根据用户权限渲染不同组件
const getComponentByRole = (role) => {
  const components = {
    admin: AdminPanel,
    user: UserPanel,
    guest: GuestPanel,
  };
  return components[role] || GuestPanel;
};

const DashboardComponent = ({ userRole }) => {
  const PanelComponent = getComponentByRole(userRole);
  return <PanelComponent />;
};
```

### 2. 组件工厂模式

**概念：** 一个组件根据输入参数创建和配置不同的子组件实例

```typescript
// 工厂组件的实现
interface BlockFactoryProps extends BaseBlockProps {
  blockType: BlockType; // 决定创建哪种组件
}

const BlockFactory = ({ blockType, ...props }) => {
  // 根据类型选择组件
  const registryItem = blockRegistry[blockType] || blockRegistry.paragraph;
  const Component = registryItem.component;

  return <Component {...props} />;
};
```

**与传统条件渲染的对比：**
```typescript
// ❌ 传统方式：违反开闭原则
const BlockRenderer = ({ blockType, ...props }) => {
  if (blockType === 'paragraph') return <ParagraphBlock {...props} />;
  if (blockType === 'h1') return <H1Block {...props} />;
  if (blockType === 'h2') return <H2Block {...props} />;
  // 每次新增类型都要修改这里
};

// ✅ 工厂模式：符合开闭原则
const BlockFactory = ({ blockType, ...props }) => {
  const Component = blockRegistry[blockType]?.component || ParagraphBlock;
  return <Component {...props} />;
};
```

### 3. 组件注册系统

**概念：** 将组件作为配置数据存储，实现插件化架构

```typescript
// 注册表数据结构
interface BlockRegistryItem {
  component: React.ForwardRefExoticComponent<BaseBlockProps & React.RefAttributes<BlockHandle>>;
  displayName: string;
  icon?: string;
  defaultContent?: string;
}

// 注册表实现
const blockRegistry: Record<BlockType, BlockRegistryItem> = {
  paragraph: {
    component: ParagraphBlock,
    displayName: "段落",
    defaultContent: "",
  },
  h1: {
    component: H1Block,
    displayName: "标题 1",
    defaultContent: "",
  },
  // 新增类型只需在这里注册
};

// 工具函数
export const getBlockDisplayName = (type: BlockType): string => {
  return blockRegistry[type]?.displayName || "未知类型";
};

export const getAvailableBlockTypes = (): BlockType[] => {
  return Object.keys(blockRegistry) as BlockType[];
};
```

**扩展性优势：**
```typescript
// 新增块类型的完整流程
// 1. 定义新类型
export type BlockType = 'paragraph' | 'h1' | 'h2' | 'h3' | 'codeBlock'; // 新增

// 2. 创建组件
const CodeBlock = forwardRef<BlockHandle, BaseBlockProps>(...);

// 3. 注册组件
const blockRegistry = {
  // ... 现有类型
  codeBlock: {
    component: CodeBlock,
    displayName: "代码块",
    defaultContent: "",
  },
};

// 4. 无需修改任何现有代码！
```

### 4. 高阶组件包装模式

**概念：** 创建包装组件来预设特定的 props，实现组件的参数化复用

```typescript
// 基础组件
interface HeadingBlockProps extends BaseBlockProps {
  headingLevel: 'h1' | 'h2' | 'h3';
}

const HeadingBlock = ({ headingLevel, ...props }) => {
  const HeadingElement = headingLevel; // 动态标签
  return <HeadingElement {...props} />;
};

// 包装组件 - 预设参数
const H1Block = forwardRef<BlockHandle, BaseBlockProps>((props, ref) => (
  <HeadingBlock {...props} ref={ref} headingLevel="h1" />
));

const H2Block = forwardRef<BlockHandle, BaseBlockProps>((props, ref) => (
  <HeadingBlock {...props} ref={ref} headingLevel="h2" />
));
```

**复用性优势：**
```typescript
// 一个基础组件，多个包装器
const ButtonBase = ({ variant, size, children, ...props }) => (
  <button className={`btn-${variant} btn-${size}`} {...props}>
    {children}
  </button>
);

// 创建专用按钮
const PrimaryButton = (props) => <ButtonBase variant="primary" {...props} />;
const SecondaryButton = (props) => <ButtonBase variant="secondary" {...props} />;
const LargeButton = (props) => <ButtonBase size="large" {...props} />;
```

### 5. 动态样式渲染

**概念：** 根据 props 动态计算样式对象，而不是硬编码样式

```typescript
const HeadingBlock = ({ headingLevel, ...props }) => {
  // 动态样式计算
  const getHeadingStyle = () => {
    const baseStyle = {
      fontWeight: "bold" as const,
      marginBottom: "8px",
    };

    switch (headingLevel) {
      case 'h1':
        return { ...baseStyle, fontSize: "32px", lineHeight: "1.2" };
      case 'h2':
        return { ...baseStyle, fontSize: "24px", lineHeight: "1.3" };
      case 'h3':
        return { ...baseStyle, fontSize: "20px", lineHeight: "1.4" };
      default:
        return baseStyle;
    }
  };

  // 动态标签名
  const HeadingElement = headingLevel;

  return (
    <HeadingElement
      style={getHeadingStyle()}
      {...props}
    />
  );
};
```

**性能考虑：**
```typescript
// ❌ 每次渲染都创建新对象
const BadComponent = ({ size }) => (
  <div style={{ fontSize: size === 'large' ? '24px' : '16px' }} />
);

// ✅ 使用 useMemo 缓存样式对象
const GoodComponent = ({ size }) => {
  const style = useMemo(() => ({
    fontSize: size === 'large' ? '24px' : '16px'
  }), [size]);

  return <div style={style} />;
};
```

### 6. 复杂的 TypeScript 类型定义

**概念：** 确保组件注册表的类型安全

```typescript
// 复杂的组件类型定义
interface BlockRegistryItem {
  component: React.ForwardRefExoticComponent<
    BaseBlockProps & React.RefAttributes<BlockHandle>
  >;
  displayName: string;
  icon?: string;
  defaultContent?: string;
}

// 类型解析：
// - React.ForwardRefExoticComponent: forwardRef 创建的组件类型
// - BaseBlockProps: 基础 props 类型
// - React.RefAttributes<BlockHandle>: ref 属性类型
// - BlockHandle: ref 对象的接口类型
```

**类型安全的好处：**
```typescript
// TypeScript 会在编译时检查类型匹配
const registry: Record<BlockType, BlockRegistryItem> = {
  paragraph: {
    component: ParagraphBlock, // ✅ 类型匹配
    displayName: "段落",
  },
  h1: {
    component: "invalid", // ❌ TypeScript 错误：类型不匹配
    displayName: "标题 1",
  },
};
```

### 7. 事件委托模式

**概念：** 将状态管理逻辑提升到父组件，子组件只负责事件触发

```typescript
// 父组件 - 处理所有状态变更
const MultiBlockEditor = () => {
  const [blocks, setBlocks] = useState<BlockData[]>([]);

  const handleTypeChange = useCallback((blockId: string, newType: BlockType) => {
    setBlocks(prevBlocks =>
      prevBlocks.map(block =>
        block.id === blockId ? { ...block, type: newType } : block
      )
    );
  }, []);

  return (
    <div>
      {blocks.map(block => (
        <BlockWrapper
          key={block.id}
          block={block}
          onTypeChange={handleTypeChange} // 传递事件处理器
        />
      ))}
    </div>
  );
};

// 子组件 - 只负责触发事件
const BlockTypeSelector = ({ currentType, onTypeChange }) => {
  const handleSelect = (type) => {
    onTypeChange(type); // 向上委托
  };

  return <select onChange={handleSelect} />;
};
```

### 8. 条件渲染与交互状态

**概念：** 基于用户交互的条件渲染

```typescript
const BlockWrapper = ({ block, ...props }) => {
  const [showTypeSelector, setShowTypeSelector] = useState(false);

  return (
    <div
      onMouseEnter={() => setShowTypeSelector(true)}
      onMouseLeave={() => setShowTypeSelector(false)}
    >
      {/* 条件渲染 - 只在鼠标悬停时显示 */}
      {showTypeSelector && (
        <BlockTypeSelector
          currentType={block.type}
          onTypeChange={(newType) => props.onTypeChange?.(block.id, newType)}
        />
      )}

      <BlockFactory blockType={block.type} {...props} />
    </div>
  );
};
```

## 🏗 设计模式总结

### 1. 工厂模式 (Factory Pattern)
- **应用：** `BlockFactory` 根据类型创建组件
- **优势：** 解耦组件创建逻辑，易于扩展

### 2. 注册模式 (Registry Pattern)
- **应用：** `blockRegistry` 管理组件映射
- **优势：** 插件化架构，运行时可扩展

### 3. 包装器模式 (Wrapper Pattern)
- **应用：** `BlockWrapper` 添加交互功能
- **优势：** 关注点分离，功能模块化

### 4. 策略模式 (Strategy Pattern)
- **应用：** 不同块类型的渲染策略
- **优势：** 算法可替换，易于维护

## 📚 学习价值

### 核心收获

1. **架构设计思维**
   - 开闭原则的实际应用
   - 组件化设计的高级模式
   - 可扩展系统的设计方法

2. **React 高级特性**
   - 动态组件渲染的原理和应用
   - 组件工厂模式的实现
   - 复杂 TypeScript 类型系统

3. **性能优化**
   - memo + useCallback 在复杂场景的应用
   - 引用稳定性在动态组件中的重要性

### 实际应用场景

这些模式在实际开发中的应用：

- **CMS 系统** - 动态页面组件
- **可视化编辑器** - 拖拽组件系统
- **仪表板系统** - 可配置图表组件
- **表单构建器** - 动态表单字段

## 🚀 下一步扩展

基于当前架构，未来可以轻松扩展：

```typescript
// 扩展示例：添加列表和媒体块
export type BlockType =
  | 'paragraph' | 'h1' | 'h2' | 'h3'
  | 'bulletList' | 'numberedList'  // 列表类型
  | 'image' | 'video' | 'embed';   // 媒体类型

// 只需添加组件和注册，无需修改现有代码
const blockRegistry = {
  // ... 现有类型
  bulletList: {
    component: BulletListBlock,
    displayName: "无序列表",
  },
  image: {
    component: ImageBlock,
    displayName: "图片",
  },
};
```

## 总结

阶段3不仅实现了块类型系统的功能，更重要的是学习了**可扩展架构设计**的思维方式。这些模式和特性为后续更复杂的功能（如拖拽、命令系统等）奠定了坚实基础。

React 的强大之处在于其灵活性 - 组件即数据，数据即组件。掌握了这个核心概念，就能构建出无限可能的应用架构。